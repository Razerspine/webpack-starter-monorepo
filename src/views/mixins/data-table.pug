//- dataTable mixin
//- Renders a flexible table from an array of objects. Columns are derived
//- from the provided `columns` array or automatically collected from object keys.
//- Supports optional index column, optional actions column (slot), per-column
//- formatters and custom header labels.
//-
//- Parameters:
//-   items       - **Array** — Array of objects to render as rows. Each object
//-                 represents one row; object keys map to columns. If not an
//-                 array, an empty table is rendered.
//-                 Example: [{ id:1, name:'Olya' }, { id:2, name:'Ivan' }]
//-                 Default: []
//-   columns     - **Array | undefined** — Optional ordered list of keys to use
//-                 as columns. If omitted or empty, unique keys are collected
//-                 from all objects in `items` and used in insertion order.
//-                 Example: ['id','name','email']
//-                 Default: auto-collected from items
//-   options     - **Object | undefined** — Additional options:
//-                 - emptyText: **String** — Text shown when no rows; Default: 'No data'.
//-                 - showIndex: **Boolean** — Render leading index column; Default: false.
//-                 - showActions: **Boolean** — Render trailing Actions column (slot); Default: true.
//-                 - formatters: **Object** — Map of column -> function(value) for custom rendering.
//-                   Example: { createdAt: v => new Date(v).toLocaleDateString() }.
//-                 - labels: **Object** — Map of column -> header label string. If absent,
//-                   header is generated by humanizing the key (underscores -> spaces, capitalized).
//-                 Default: {}
//-
//- Behavior:
//-   - If `items` is empty, a single header cell spanning all columns displays `emptyText`.
//-   - Column order follows `columns` if provided; otherwise it follows the unique keys
//-     discovered across `items`.
//-   - For each cell, `formatters[col]` is used when present; otherwise arrays are joined,
//-     objects are JSON-stringified, and primitives are stringified.
//-   - The Actions column is a slot: when `showActions` is true, the mixin renders a `td`
//-     containing the caller-provided block. Inside the block the current row object is
//-     available as `item` and the row index as `i`.
//-
//- Notes and best practices:
//-   - Prefer passing an explicit `columns` array when you need stable column order.
//-   - Use `labels` for human-friendly or localized header text instead of renaming keys.
//-   - Keep `formatters` pure and return safe strings; if returning HTML, use `!=` in the mixin call
//-     or return already-escaped content carefully to avoid XSS.
//-   - To hide the Actions column entirely, set `showActions: false` in `options`.
//-   - For large datasets, consider server-side pagination or client-side slicing before passing `items`.
//-
//- Examples:
//-   // Basic usage with auto columns
//-   - const data = [{ id:1, name:'Olya' }, { id:2, name:'Ivan' }]
//-   +dataTable(data)
//-
//-   // Explicit columns, labels and formatters
//-   +dataTable(data, ['id','name'], {
//-     showIndex: true,
//-     showActions: false,
//-     labels: { id: 'ID', name: 'Full name' },
//-     formatters: { id: v => '#' + v }
//-   })
//-
//-   // With Actions slot (edit/delete links). Inside block `item` is current row.
//-   +dataTable(data, ['id','name'], { showActions: true })
//-     a(href='/edit/#{item && item.id || ""}') Edit
//-     |
//-     a(href='/delete/#{item && item.id || ""}') Delete
//-
//- Keep this docblock updated when you change parameter names, defaults, or
//- the mixin behavior so editor hover comments remain accurate.
mixin dataTable(items, columns, options)
  - const _items = Array.isArray(items) ? items : [];
  - const cols = Array.isArray(columns) && columns.length ? columns : Array.from(new Set(_items.reduce((acc, it) => acc.concat(Object.keys(it || {})), [])));
  - const opts = Object.assign({ emptyText: 'No data', showIndex: false, showActions: false, formatters: {}, labels: {} }, options || {});

  - const humanize = function(key) {
  -   if (!key && key !== 0) return '';
  -   const s = String(key).replace(/_/g, ' ');
  -   return s.charAt(0).toUpperCase() + s.slice(1);
  - }

  - const formatValue = function(v, col) {
  -   if (v === null || v === undefined || v === '') return '';
  -   if (opts.formatters && typeof opts.formatters[col] === 'function') return opts.formatters[col](v);
  -   if (Array.isArray(v)) return v.join(', ');
  -   if (typeof v === 'object') return JSON.stringify(v);
  -   return String(v);
  - }

  if !_items.length
    table.table
      thead
        tr
          th(colspan=cols.length + (opts.showIndex ? 1 : 0) + (opts.showActions ? 1 : 0)) #{opts.emptyText}
  else
    table.table
      thead
        tr
          if opts.showIndex
            th #
          each col in cols
            - const label = (opts.labels && Object.prototype.hasOwnProperty.call(opts.labels, col)) ? opts.labels[col] : humanize(col)
            th #{label}
          if opts.showActions
            th Actions
      tbody
        each item, i in _items
          tr
            if opts.showIndex
              td #{i + 1}
            each col in cols
              - const val = (item && Object.prototype.hasOwnProperty.call(item, col)) ? item[col] : ''
              td!= formatValue(val, col)
            if opts.showActions
              td
                block
